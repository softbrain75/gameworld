<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="mobile-web-app-capable" content="yes">
    <title>오목 게임</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
            font-family: 'Malgun Gothic', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }

        #menuScreen, #gameoverScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            z-index: 10;
            padding: 20px;
        }

        h1 {
            font-size: 3em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .instructions {
            font-size: 1.2em;
            text-align: center;
            margin-bottom: 30px;
            line-height: 1.6;
            max-width: 600px;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        #gameCanvas {
            display: none;
            background: #daa520;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            border: 3px solid #8b4513;
        }

        #gameoverScreen {
            display: none;
        }

        .score {
            font-size: 2em;
            margin: 20px 0;
        }

        .highscore {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.8;
        }

        #turnIndicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 30px;
            border-radius: 10px;
            display: none;
            z-index: 5;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #resetBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            font-size: 1em;
            background: rgba(255, 100, 100, 0.8);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            z-index: 5;
        }

        #resetBtn:active {
            transform: scale(0.95);
        }

        .mode-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            transform: scale(1.1);
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="menuScreen">
        <h1>🎯 오목 게임</h1>
        <div class="instructions">
            바둑판에 돌을 놓아 가로, 세로, 대각선 중<br>
            하나의 방향으로 다섯 개를 먼저 만드는 사람이 승리!<br><br>
            검은 돌이 먼저 시작합니다.
        </div>
        <div class="mode-selector">
            <button class="mode-btn selected" id="vsPlayerBtn">👥 2인 대전</button>
            <button class="mode-btn" id="vsAIBtn">🤖 AI 대전</button>
        </div>
        <div class="highscore">최고 승수: <span id="menuHighScore">0</span>승</div>
        <button class="btn" id="startBtn">게임 시작</button>
    </div>

    <div id="gameoverScreen">
        <h1>게임 종료!</h1>
        <div class="score" id="winnerText">검은 돌 승리!</div>
        <div class="highscore">총 승수: <span id="totalWins">0</span>승</div>
        <div class="highscore">최고 승수: <span id="gameoverHighScore">0</span>승</div>
        <button class="btn" id="retryBtn">다시 하기</button>
    </div>

    <div id="turnIndicator">검은 돌 차례</div>
    <button id="resetBtn">처음으로</button>

    <canvas id="gameCanvas"></canvas>

    <script>
        // Viewport height fix for mobile
        function setVh() {
            let vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        setVh();
        window.addEventListener('resize', setVh);

        // Audio
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playSound(soundType) {
            try {
                initAudio();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                switch(soundType) {
                    case 'place':
                        oscillator.frequency.value = 440;
                        gainNode.gain.value = 0.08;
                        oscillator.type = 'sine';
                        break;
                    case 'win':
                        oscillator.frequency.value = 800;
                        gainNode.gain.value = 0.12;
                        oscillator.type = 'sine';
                        break;
                    case 'draw':
                        oscillator.frequency.value = 300;
                        gainNode.gain.value = 0.10;
                        oscillator.type = 'sine';
                        break;
                }

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {}
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menuScreen');
        const gameoverScreen = document.getElementById('gameoverScreen');
        const turnIndicator = document.getElementById('turnIndicator');
        const resetBtn = document.getElementById('resetBtn');

        let gameState = 'menu';
        let currentPlayer = 'black'; // 'black' or 'white'
        let board = [];
        let boardSize = 15;
        let cellSize;
        let padding;
        let totalWins = 0;
        let highScore = 0;
        let gameMode = 'vsPlayer'; // 'vsPlayer' or 'vsAI'

        // Load high score
        const savedHighScore = localStorage.getItem('omok_highScore');
        if (savedHighScore) {
            highScore = parseInt(savedHighScore);
            document.getElementById('menuHighScore').textContent = highScore;
        }

        // Mode selection
        document.getElementById('vsPlayerBtn').addEventListener('click', () => {
            gameMode = 'vsPlayer';
            document.getElementById('vsPlayerBtn').classList.add('selected');
            document.getElementById('vsAIBtn').classList.remove('selected');
        });

        document.getElementById('vsAIBtn').addEventListener('click', () => {
            gameMode = 'vsAI';
            document.getElementById('vsAIBtn').classList.add('selected');
            document.getElementById('vsPlayerBtn').classList.remove('selected');
        });

        // Start button
        document.getElementById('startBtn').addEventListener('click', startGame);

        // Retry button
        document.getElementById('retryBtn').addEventListener('click', () => {
            gameoverScreen.style.display = 'none';
            menuScreen.style.display = 'flex';
            gameState = 'menu';
        });

        // Reset button
        resetBtn.addEventListener('click', () => {
            canvas.style.display = 'none';
            turnIndicator.style.display = 'none';
            resetBtn.style.display = 'none';
            menuScreen.style.display = 'flex';
            gameState = 'menu';
        });

        function startGame() {
            menuScreen.style.display = 'none';
            canvas.style.display = 'block';
            turnIndicator.style.display = 'block';
            resetBtn.style.display = 'block';
            gameState = 'playing';

            initGame();
        }

        function initGame() {
            // Set canvas size
            const maxSize = Math.min(window.innerWidth, window.innerHeight) * 0.9;
            canvas.width = maxSize;
            canvas.height = maxSize;

            // Calculate cell size and padding
            padding = maxSize * 0.05;
            cellSize = (maxSize - padding * 2) / (boardSize - 1);

            // Initialize board
            board = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
            currentPlayer = 'black';
            updateTurnIndicator();

            drawBoard();
        }

        function drawBoard() {
            ctx.fillStyle = '#daa520';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            for (let i = 0; i < boardSize; i++) {
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(padding, padding + i * cellSize);
                ctx.lineTo(padding + (boardSize - 1) * cellSize, padding + i * cellSize);
                ctx.stroke();

                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(padding + i * cellSize, padding);
                ctx.lineTo(padding + i * cellSize, padding + (boardSize - 1) * cellSize);
                ctx.stroke();
            }

            // Draw star points
            const starPoints = [
                [3, 3], [3, 11], [11, 3], [11, 11], [7, 7]
            ];
            ctx.fillStyle = '#000';
            starPoints.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(padding + x * cellSize, padding + y * cellSize, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw stones
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j]) {
                        drawStone(i, j, board[i][j]);
                    }
                }
            }
        }

        function drawStone(row, col, color) {
            const x = padding + col * cellSize;
            const y = padding + row * cellSize;
            const radius = cellSize * 0.4;

            // Shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;

            // Stone
            const gradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
            if (color === 'black') {
                gradient.addColorStop(0, '#555');
                gradient.addColorStop(1, '#000');
            } else {
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ddd');
            }

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function updateTurnIndicator() {
            turnIndicator.textContent = currentPlayer === 'black' ? '● 검은 돌 차례' : '○ 흰 돌 차례';
            turnIndicator.style.color = currentPlayer === 'black' ? '#000' : '#fff';
            turnIndicator.style.background = currentPlayer === 'black' ?
                'rgba(255, 255, 255, 0.9)' : 'rgba(0, 0, 0, 0.9)';
        }

        // Canvas click/touch handling
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleCanvasClick(touch);
        });

        function handleCanvasClick(e) {
            if (gameState !== 'playing') return;
            if (gameMode === 'vsAI' && currentPlayer === 'white') return; // Wait for AI

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Convert to grid position
            const col = Math.round((x - padding) / cellSize);
            const row = Math.round((y - padding) / cellSize);

            // Check if valid position
            if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) return;
            if (board[row][col]) return; // Already occupied

            // Place stone
            placeStone(row, col);
        }

        function placeStone(row, col) {
            board[row][col] = currentPlayer;
            playSound('place');
            drawBoard();

            // Check win
            if (checkWin(row, col)) {
                playSound('win');
                gameOver(currentPlayer);
                return;
            }

            // Check draw
            if (isBoardFull()) {
                playSound('draw');
                gameOver(null);
                return;
            }

            // Switch player
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            updateTurnIndicator();

            // AI move
            if (gameMode === 'vsAI' && currentPlayer === 'white' && gameState === 'playing') {
                setTimeout(makeAIMove, 500);
            }
        }

        function makeAIMove() {
            // Enhanced AI with threat detection
            let bestScore = -Infinity;
            let bestMove = null;

            // First check for immediate win or block
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (!board[i][j]) {
                        // Check if AI can win
                        board[i][j] = 'white';
                        if (checkWin(i, j)) {
                            board[i][j] = null;
                            placeStone(i, j);
                            return;
                        }
                        board[i][j] = null;

                        // Check if must block player from winning
                        board[i][j] = 'black';
                        if (checkWin(i, j)) {
                            board[i][j] = null;
                            placeStone(i, j);
                            return;
                        }
                        board[i][j] = null;
                    }
                }
            }

            // Check for critical threats (4 in a row with one end open)
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (!board[i][j]) {
                        const threatLevel = checkThreatLevel(i, j);
                        if (threatLevel.playerThreat >= 4) {
                            placeStone(i, j);
                            return;
                        }
                    }
                }
            }

            // Evaluate all positions
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (!board[i][j]) {
                        const score = evaluatePosition(i, j);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = [i, j];
                        }
                    }
                }
            }

            if (bestMove) {
                placeStone(bestMove[0], bestMove[1]);
            }
        }

        function checkThreatLevel(row, col) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            let maxAIThreat = 0;
            let maxPlayerThreat = 0;

            directions.forEach(([dx, dy]) => {
                // Check AI threat
                board[row][col] = 'white';
                const aiCount = countInDirection(row, col, dx, dy, 'white');
                maxAIThreat = Math.max(maxAIThreat, aiCount);
                board[row][col] = null;

                // Check player threat
                board[row][col] = 'black';
                const playerCount = countInDirection(row, col, dx, dy, 'black');
                maxPlayerThreat = Math.max(maxPlayerThreat, playerCount);
                board[row][col] = null;
            });

            return { aiThreat: maxAIThreat, playerThreat: maxPlayerThreat };
        }

        function countInDirection(row, col, dx, dy, color) {
            let count = 1;

            // Count in positive direction
            let i = 1;
            while (i < 5) {
                const newRow = row + dx * i;
                const newCol = col + dy * i;
                if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) break;
                if (board[newRow][newCol] === color) {
                    count++;
                    i++;
                } else {
                    break;
                }
            }

            // Count in negative direction
            i = 1;
            while (i < 5) {
                const newRow = row - dx * i;
                const newCol = col - dy * i;
                if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) break;
                if (board[newRow][newCol] === color) {
                    count++;
                    i++;
                } else {
                    break;
                }
            }

            return count;
        }

        function evaluatePosition(row, col) {
            let score = 0;

            const threatLevel = checkThreatLevel(row, col);

            // Prioritize blocking dangerous threats
            if (threatLevel.playerThreat >= 3) {
                score += 8000;
            } else if (threatLevel.playerThreat >= 2) {
                score += 500;
            }

            // Prioritize creating threats
            if (threatLevel.aiThreat >= 3) {
                score += 6000;
            } else if (threatLevel.aiThreat >= 2) {
                score += 300;
            }

            // Evaluate pattern quality
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            directions.forEach(([dx, dy]) => {
                score += evaluateDirection(row, col, dx, dy, 'white') * 15;
                score += evaluateDirection(row, col, dx, dy, 'black') * 10;
            });

            // Strategic positioning
            const centerDist = Math.abs(row - 7) + Math.abs(col - 7);
            score += (14 - centerDist) * 3;

            // Prefer positions near existing stones
            let adjacentStones = 0;
            for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                    const nr = row + dr;
                    const nc = col + dc;
                    if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
                        if (board[nr][nc]) adjacentStones++;
                    }
                }
            }
            score += adjacentStones * 20;

            return score;
        }

        function evaluateDirection(row, col, dx, dy, color) {
            let count = 1;
            let openEnds = 0;
            let blocked = 0;

            // Check positive direction
            let i = 1;
            while (i <= 4) {
                const newRow = row + dx * i;
                const newCol = col + dy * i;
                if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) {
                    blocked++;
                    break;
                }
                if (board[newRow][newCol] === color) {
                    count++;
                    i++;
                } else if (!board[newRow][newCol]) {
                    openEnds++;
                    break;
                } else {
                    blocked++;
                    break;
                }
            }

            // Check negative direction
            i = 1;
            while (i <= 4) {
                const newRow = row - dx * i;
                const newCol = col - dy * i;
                if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) {
                    blocked++;
                    break;
                }
                if (board[newRow][newCol] === color) {
                    count++;
                    i++;
                } else if (!board[newRow][newCol]) {
                    openEnds++;
                    break;
                } else {
                    blocked++;
                    break;
                }
            }

            // Scoring based on pattern quality
            if (blocked === 2) return 0; // Dead pattern
            if (count >= 4) return 10000; // Almost winning
            if (count === 3 && openEnds === 2) return 5000; // Open three
            if (count === 3 && openEnds === 1) return 1000; // Semi-open three
            if (count === 2 && openEnds === 2) return 500; // Open two
            if (count === 2 && openEnds === 1) return 100; // Semi-open two

            return count * count * (openEnds + 1);
        }

        function checkWin(row, col) {
            const directions = [
                [1, 0],  // horizontal
                [0, 1],  // vertical
                [1, 1],  // diagonal \
                [1, -1]  // diagonal /
            ];

            for (let [dx, dy] of directions) {
                let count = 1;

                // Check positive direction
                let i = 1;
                while (true) {
                    const newRow = row + dx * i;
                    const newCol = col + dy * i;
                    if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) break;
                    if (board[newRow][newCol] === board[row][col]) {
                        count++;
                        i++;
                    } else {
                        break;
                    }
                }

                // Check negative direction
                i = 1;
                while (true) {
                    const newRow = row - dx * i;
                    const newCol = col - dy * i;
                    if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) break;
                    if (board[newRow][newCol] === board[row][col]) {
                        count++;
                        i++;
                    } else {
                        break;
                    }
                }

                if (count >= 5) return true;
            }

            return false;
        }

        function isBoardFull() {
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (!board[i][j]) return false;
                }
            }
            return true;
        }

        function gameOver(winner) {
            gameState = 'gameover';
            canvas.style.display = 'none';
            turnIndicator.style.display = 'none';
            resetBtn.style.display = 'none';

            if (winner) {
                totalWins++;
                if (totalWins > highScore) {
                    highScore = totalWins;
                    localStorage.setItem('omok_highScore', highScore);
                }
                document.getElementById('winnerText').textContent =
                    winner === 'black' ? '● 검은 돌 승리!' : '○ 흰 돌 승리!';
            } else {
                document.getElementById('winnerText').textContent = '무승부!';
            }

            document.getElementById('totalWins').textContent = totalWins;
            document.getElementById('gameoverHighScore').textContent = highScore;
            gameoverScreen.style.display = 'flex';
        }
    </script>
</body>
</html>
