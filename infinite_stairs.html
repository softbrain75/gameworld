<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9906225455543284"
     crossorigin="anonymous"></script>
    <title>무한의 계단 ⬆️</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            width: 100vw;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
            font-family: 'Malgun Gothic', sans-serif;
            background: #1a1a2e;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            display: block;
            background: #1a1a2e;
            max-width: 100%;
            max-height: 100%;
            width: 100vw;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        .info {
            font-size: 1.1rem;
            margin: 0.5rem 0;
            text-align: center;
            padding: 0 2rem;
        }

        button {
            font-size: 1.5rem;
            padding: 1rem 3rem;
            margin: 1rem;
            border: none;
            border-radius: 10px;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        button:active {
            transform: scale(0.95);
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            z-index: 5;
        }

        .score {
            color: white;
            font-size: 2.5rem;
            text-align: center;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }

        .health-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid white;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.8);
        }

        .controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            display: none;
            z-index: 5;
        }

        .controls.active {
            display: flex;
        }

        .control-btn {
            flex: 1;
            border: none;
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            opacity: 0.85;
            transition: opacity 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 10px;
            border-top: 3px solid rgba(255, 255, 255, 0.3);
        }

        .control-btn.left {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.7), rgba(41, 128, 185, 0.7));
        }

        .control-btn.right {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.7), rgba(192, 57, 43, 0.7));
        }

        .control-btn:active {
            opacity: 1;
            transform: scale(0.98);
        }

        .key-label {
            font-size: 1rem;
            opacity: 0.9;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .info { font-size: 1rem; }
            button { font-size: 1.2rem; padding: 0.8rem 2rem; }
            .score { font-size: 2rem; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="menuScreen" class="screen">
        <h1>⬆️ 무한의 계단</h1>
        <div class="info">좌우로 이어지는 계단을 올라가세요!</div>
        <div class="info">계단 끝에서 방향을 전환하세요!</div>
        <div class="info">체력이 다 닳기 전에 계단을 올라야 합니다!</div>
        <div class="info" style="margin-top: 1rem;">최고 기록: <span id="menuHighScore">0</span>층</div>
        <button id="startBtn">게임 시작</button>
    </div>

    <div id="gameoverScreen" class="screen hidden">
        <h1>게임 오버</h1>
        <div class="info">도달 층수: <span id="finalScore">0</span>층</div>
        <div class="info">최고 기록: <span id="gameoverHighScore">0</span>층</div>
        <button id="retryBtn">다시 하기</button>
    </div>

    <div class="hud hidden" id="gameHud">
        <div class="score" id="scoreDisplay">0</div>
        <div class="health-bar">
            <div class="health-fill" id="healthFill"></div>
        </div>
    </div>

    <div class="controls" id="controls">
        <button class="control-btn left" id="turnBtn">
            <div>방향전환</div>
            <div class="key-label">Z 또는 ←</div>
        </button>
        <button class="control-btn right" id="climbBtn">
            <div>오르기</div>
            <div class="key-label">X 또는 →</div>
        </button>
    </div>

    <script>
        // Viewport height fix for mobile
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        window.addEventListener('resize', () => {
            vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameState = 'menu';
        let highScore = parseInt(localStorage.getItem('infiniteStairs_highScore')) || 0;

        // Player (fixed on screen)
        const player = {
            stairIndex: 0,
            direction: 1, // 1 = right, -1 = left
            climbing: false,
            climbProgress: 0,
            size: 35
        };

        // Game variables
        let stairs = [];
        let score = 0;
        let health = 100;
        let healthDecayRate = 0.5; // Faster decay rate
        let cameraY = 0;
        let cameraX = 0; // Camera X position for left-right movement
        const stairWidth = 80;
        const stairHeight = 40;
        const stairDepth = 50; // Visual depth for 3D effect

        // Input
        const keys = {};
        const keysPressed = {}; // Track if key is already pressed

        // Audio context
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playSound(type) {
            try {
                initAudio();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                switch(type) {
                    case 'step':
                        oscillator.frequency.value = 400 + Math.random() * 100;
                        gainNode.gain.value = 0.1;
                        oscillator.type = 'sine';
                        break;
                    case 'turn':
                        oscillator.frequency.value = 600;
                        gainNode.gain.value = 0.08;
                        oscillator.type = 'sine';
                        break;
                    case 'fall':
                        oscillator.frequency.value = 100;
                        gainNode.gain.value = 0.12;
                        oscillator.type = 'sine';
                        break;
                }

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.08);
            } catch (e) {}
        }

        // Initialize stairs
        function initStairs() {
            stairs = [];
            let currentX = 0;
            let currentDirection = 1; // 1 = right, -1 = left
            let stepsInDirection = Math.floor(Math.random() * 3) + 4; // 4-6 steps
            let stepCount = 0;

            for (let i = 0; i < 40; i++) {
                stairs.push({
                    x: currentX,
                    y: i,
                    direction: currentDirection,
                    isTurn: false
                });

                stepCount++;

                // Check if it's time to turn
                if (stepCount >= stepsInDirection) {
                    stairs[i].isTurn = true;
                    currentDirection *= -1; // Switch direction
                    stairs[i].direction = currentDirection; // Turn block faces new direction
                    stepCount = 0;
                    stepsInDirection = Math.floor(Math.random() * 3) + 4;
                }

                // Move X for next stair
                currentX += currentDirection * stairWidth;
            }
        }

        // Game loop
        function update() {
            if (gameState !== 'playing') return;

            // Health decay only when player has moved at least once
            if (score > 0) {
                health -= healthDecayRate;
                if (health <= 0) {
                    gameOver();
                    return;
                }

                // Update health bar
                document.getElementById('healthFill').style.width = health + '%';

                // Increase difficulty - gets faster as you climb
                healthDecayRate = 0.5 + (score * 0.02);
            }

            // Input handling removed from update loop - now handled in keydown event

            // Climbing animation
            if (player.climbing) {
                player.climbProgress += 0.15;
                if (player.climbProgress >= 1) {
                    player.climbing = false;
                    player.climbProgress = 0;
                    player.stairIndex++;

                    // Generate more stairs early to prevent running out
                    if (player.stairIndex >= stairs.length - 10) {
                        generateMoreStairs();
                    }
                }
            }

            // Camera follows player position smoothly - player stays in same spot on screen, world moves
            const currentPlayerY = player.stairIndex + (player.climbing ? player.climbProgress : 0);
            cameraY = currentPlayerY * stairHeight;

            // Camera X follows current stair position with interpolation during climb
            const currentStair = stairs[player.stairIndex];
            if (currentStair) {
                if (player.climbing && player.stairIndex + 1 < stairs.length) {
                    const nextStair = stairs[player.stairIndex + 1];
                    // Smoothly interpolate X position during climb animation
                    cameraX = currentStair.x + (nextStair.x - currentStair.x) * player.climbProgress;
                } else {
                    cameraX = currentStair.x;
                }
            }
        }

        function climbStair() {
            const currentStair = stairs[player.stairIndex];

            // Check if at a turn point
            if (currentStair.isTurn) {
                gameOver();
                return;
            }

            player.climbing = true;
            player.climbProgress = 0;
            score++;
            health = Math.min(100, health + 50); // Add 50% health
            document.getElementById('scoreDisplay').textContent = score;
            playSound('step');
        }

        function turnAndClimb() {
            const currentStair = stairs[player.stairIndex];

            // Only allow turning at turn points
            if (!currentStair.isTurn) {
                gameOver();
                return;
            }

            player.direction *= -1;
            player.climbing = true;
            player.climbProgress = 0;
            score++;
            health = Math.min(100, health + 50); // Add 50% health
            document.getElementById('scoreDisplay').textContent = score;
            playSound('turn');
        }

        function generateMoreStairs() {
            const lastStair = stairs[stairs.length - 1];
            let currentX = lastStair.x + lastStair.direction * stairWidth; // Start from next position
            let currentDirection = lastStair.direction;
            let stepsInDirection = Math.floor(Math.random() * 3) + 4;
            let stepCount = 1; // Already counted lastStair

            for (let i = 0; i < 20; i++) {
                const y = stairs.length;

                stairs.push({
                    x: currentX,
                    y: y,
                    direction: currentDirection,
                    isTurn: false
                });

                stepCount++;

                if (stepCount >= stepsInDirection) {
                    stairs[stairs.length - 1].isTurn = true;
                    currentDirection *= -1; // Switch direction
                    stairs[stairs.length - 1].direction = currentDirection; // Turn block faces new direction
                    stepCount = 0;
                    stepsInDirection = Math.floor(Math.random() * 3) + 4;
                }

                // Move X for next stair
                currentX += currentDirection * stairWidth;
            }

            // Don't remove old stairs to prevent index issues
            // Keep all stairs for consistent rendering
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();

            const centerX = canvas.width / 2;
            const startY = canvas.height * 0.65; // Player at 65% - middle of screen

            // Draw stairs
            stairs.forEach((stair, index) => {
                // Convert cameraY (pixels) back to stair index for calculation
                const cameraStairIndex = cameraY / stairHeight;
                const screenY = startY - (stair.y - cameraStairIndex) * stairDepth;

                if (screenY > -100 && screenY < canvas.height + 100) {
                    // Apply camera X offset - stairs move left/right as player climbs
                    const x = centerX + (stair.x - cameraX);

                    // Stair depth/shadow
                    ctx.fillStyle = '#2d3436';
                    ctx.fillRect(x - stairWidth/2, screenY + 5, stairWidth, stairHeight);

                    // Stair color (highlight current stair)
                    if (index === player.stairIndex) {
                        ctx.fillStyle = '#4CAF50';
                    } else if (stair.isTurn) {
                        ctx.fillStyle = '#e74c3c'; // Red for turn points
                    } else {
                        ctx.fillStyle = '#636e72';
                    }
                    ctx.fillRect(x - stairWidth/2, screenY, stairWidth, stairHeight);

                    // Stair outline
                    ctx.strokeStyle = '#dfe6e9';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - stairWidth/2, screenY, stairWidth, stairHeight);

                    // Turn indicator
                    if (stair.isTurn) {
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 20px Malgun Gothic';
                        ctx.textAlign = 'center';
                        ctx.fillText('⟲', x, screenY + stairHeight/2 + 7);
                    }
                }
            });

            // Draw player - FIXED position on screen (center)
            // Player always stays at same position, world moves around them
            const playerX = centerX;
            const playerY = startY - stairHeight; // Position player on TOP of stair

            // Player shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(playerX, playerY + player.size/2 + 5, player.size * 0.6, player.size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Player body
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.arc(playerX, playerY - player.size/4, player.size/2, 0, Math.PI * 2);
            ctx.fill();

            // Player outline
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Direction indicator
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(playerX + player.direction * 12, playerY - player.size/4, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = 'playing';
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameoverScreen').classList.add('hidden');
            document.getElementById('gameHud').classList.remove('hidden');
            document.getElementById('controls').classList.add('active');

            // Reset
            player.stairIndex = 0;
            player.direction = 1;
            player.climbing = false;
            player.climbProgress = 0;
            score = 0;
            health = 100;
            healthDecayRate = 0.5;
            cameraY = 0;
            cameraX = 0;

            initStairs();
            initAudio();

            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('healthFill').style.width = '100%';
        }

        function gameOver() {
            gameState = 'gameover';
            playSound('fall');
            document.getElementById('gameHud').classList.add('hidden');
            document.getElementById('controls').classList.remove('active');
            document.getElementById('gameoverScreen').classList.remove('hidden');

            document.getElementById('finalScore').textContent = score;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('infiniteStairs_highScore', highScore);
            }

            document.getElementById('gameoverHighScore').textContent = highScore;
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('retryBtn').addEventListener('click', startGame);

        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing' || player.climbing) return;

            // Prevent key repeat - only trigger once per key press
            if (keysPressed[e.key]) return;
            keysPressed[e.key] = true;

            if (e.key === 'x' || e.key === 'X' || e.key === 'ArrowRight') {
                e.preventDefault();
                climbStair();
            }
            if (e.key === 'z' || e.key === 'Z' || e.key === 'ArrowLeft') {
                e.preventDefault();
                turnAndClimb();
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        // Touch controls
        document.getElementById('turnBtn').addEventListener('click', (e) => {
            e.preventDefault();
            if (!player.climbing) turnAndClimb();
        });

        document.getElementById('climbBtn').addEventListener('click', (e) => {
            e.preventDefault();
            if (!player.climbing) climbStair();
        });

        // High score display
        document.getElementById('menuHighScore').textContent = highScore;
        document.getElementById('gameoverHighScore').textContent = highScore;

        // Start game loop
        gameLoop();
    </script>
</body>
</html>
