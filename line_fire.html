import React, { useState, useEffect, useRef } from 'react';
import { Trophy, Heart, Target, Zap, Shield, Flame } from 'lucide-react';

const MultiLaneTapDefense = () => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('menu');
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  const [wave, setWave] = useState(1);
  const [lives, setLives] = useState(10);
  const [enemies, setEnemies] = useState([]);
  const [projectiles, setProjectiles] = useState([]);
  const [effects, setEffects] = useState([]);
  const [combo, setCombo] = useState(0);
  const [maxCombo, setMaxCombo] = useState(0);
  const [kills, setKills] = useState(0);
  const [cannons, setCannons] = useState([]);

  const CANVAS_WIDTH = 800;
  const CANVAS_HEIGHT = 600;
  const NUM_LANES = 5;
  const LANE_WIDTH = CANVAS_WIDTH / NUM_LANES;
  const CANNON_COOLDOWN = 800; // ms

  const enemyTypes = [
    { type: 'normal', color: '#e74c3c', health: 1, speed: 1.5, points: 10, size: 30 },
    { type: 'fast', color: '#3498db', health: 1, speed: 3, points: 20, size: 25 },
    { type: 'tank', color: '#9b59b6', health: 3, speed: 1, points: 30, size: 40 },
    { type: 'boss', color: '#f39c12', health: 5, speed: 0.7, points: 100, size: 50 }
  ];

  useEffect(() => {
    const saved = localStorage.getItem('laneDefenderHighScore');
    if (saved) setHighScore(parseInt(saved));
  }, []);

  useEffect(() => {
    if (gameState !== 'playing') return;

    // Spawn enemies
    const spawnInterval = setInterval(() => {
      const waveMultiplier = Math.min(wave, 10);
      const spawnCount = 2 + Math.floor(waveMultiplier / 2);

      for (let i = 0; i < spawnCount; i++) {
        setTimeout(() => {
          const lane = Math.floor(Math.random() * NUM_LANES);
          
          let enemyType;
          const rand = Math.random();
          if (wave < 3) {
            enemyType = enemyTypes[0];
          } else if (wave < 6) {
            enemyType = rand < 0.7 ? enemyTypes[0] : enemyTypes[1];
          } else if (wave < 10) {
            if (rand < 0.5) enemyType = enemyTypes[0];
            else if (rand < 0.8) enemyType = enemyTypes[1];
            else enemyType = enemyTypes[2];
          } else {
            if (rand < 0.4) enemyType = enemyTypes[0];
            else if (rand < 0.7) enemyTypes[1];
            else if (rand < 0.95) enemyType = enemyTypes[2];
            else enemyType = enemyTypes[3];
          }

          setEnemies(prev => [...prev, {
            id: Date.now() + Math.random(),
            ...enemyType,
            lane,
            x: lane * LANE_WIDTH + LANE_WIDTH / 2,
            y: -enemyType.size,
            maxHealth: enemyType.health
          }]);
        }, i * 600);
      }
    }, 3000);

    return () => clearInterval(spawnInterval);
  }, [gameState, wave]);

  useEffect(() => {
    if (lives <= 0 && gameState === 'playing') {
      setGameState('gameover');
      if (score > highScore) {
        setHighScore(score);
        localStorage.setItem('laneDefenderHighScore', score.toString());
      }
    }
  }, [lives]);

  useEffect(() => {
    if (kills > 0 && kills % 15 === 0) {
      setWave(prev => prev + 1);
    }
  }, [kills]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    let animationFrameId;

    const gameLoop = () => {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Background
      const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#16213e');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Draw lanes
      for (let i = 0; i < NUM_LANES; i++) {
        const x = i * LANE_WIDTH;
        
        ctx.fillStyle = i % 2 === 0 ? 'rgba(30, 30, 50, 0.5)' : 'rgba(40, 40, 60, 0.5)';
        ctx.fillRect(x, 0, LANE_WIDTH, CANVAS_HEIGHT);
        
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(x + LANE_WIDTH / 2, 0);
        ctx.lineTo(x + LANE_WIDTH / 2, CANVAS_HEIGHT - 100);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${i + 1}`, x + LANE_WIDTH / 2, 40);
      }

      // Draw cannons at bottom
      const cannonY = CANVAS_HEIGHT - 70;
      cannons.forEach((cannon, i) => {
        const x = i * LANE_WIDTH + LANE_WIDTH / 2;
        
        // Cannon base
        ctx.fillStyle = '#555';
        ctx.fillRect(x - 25, cannonY + 20, 50, 30);
        
        // Cannon barrel
        ctx.fillStyle = cannon.canFire ? '#4CAF50' : '#999';
        ctx.shadowColor = cannon.canFire ? '#4CAF50' : 'transparent';
        ctx.shadowBlur = cannon.canFire ? 15 : 0;
        ctx.fillRect(x - 15, cannonY - 30, 30, 50);
        ctx.shadowBlur = 0;
        
        // Cannon tip
        ctx.fillStyle = cannon.canFire ? '#66BB6A' : '#aaa';
        ctx.beginPath();
        ctx.arc(x, cannonY - 30, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Cooldown indicator
        if (!cannon.canFire) {
          const cooldownPercent = (Date.now() - cannon.lastFired) / CANNON_COOLDOWN;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.fillRect(x - 25, cannonY + 55, 50 * (1 - cooldownPercent), 5);
        }
        
        // Ready indicator
        if (cannon.canFire) {
          ctx.fillStyle = '#4CAF50';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('READY', x, cannonY + 70);
        }
      });

      // Update and draw enemies
      setEnemies(prev => {
        return prev.map(enemy => {
          enemy.y += enemy.speed;

          if (enemy.y > CANVAS_HEIGHT - 120) {
            setLives(l => Math.max(0, l - 1));
            setCombo(0);
            
            for (let i = 0; i < 10; i++) {
              setEffects(e => [...e, {
                id: Date.now() + Math.random(),
                x: enemy.x,
                y: CANVAS_HEIGHT - 100,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: 30,
                color: '#ff0000',
                size: 8
              }]);
            }
            
            return null;
          }

          return enemy;
        }).filter(e => e !== null);
      });

      // Draw enemies
      enemies.forEach(enemy => {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(enemy.x + 3, enemy.y + 3, enemy.size / 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = enemy.color;
        ctx.shadowColor = enemy.color;
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(enemy.x - 8, enemy.y - 5, 5, 0, Math.PI * 2);
        ctx.arc(enemy.x + 8, enemy.y - 5, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(enemy.x - 8, enemy.y - 5, 3, 0, Math.PI * 2);
        ctx.arc(enemy.x + 8, enemy.y - 5, 3, 0, Math.PI * 2);
        ctx.fill();

        if (enemy.health < enemy.maxHealth) {
          const barWidth = enemy.size;
          const barHeight = 5;
          const barX = enemy.x - barWidth / 2;
          const barY = enemy.y - enemy.size / 2 - 10;

          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(barX, barY, barWidth, barHeight);

          const healthColor = enemy.health / enemy.maxHealth > 0.5 ? '#2ecc71' : '#e74c3c';
          ctx.fillStyle = healthColor;
          ctx.fillRect(barX, barY, barWidth * (enemy.health / enemy.maxHealth), barHeight);
        }
      });

      // Update and draw projectiles
      setProjectiles(prev => {
        return prev.map(proj => {
          proj.y -= proj.speed;
          
          if (proj.y < -20) return null;

          // Check collision with enemies
          let hit = false;
          setEnemies(prevEnemies => {
            return prevEnemies.map(enemy => {
              if (enemy.lane === proj.lane && !hit) {
                const distance = Math.abs(enemy.y - proj.y);
                
                if (distance < 30) {
                  hit = true;
                  enemy.health -= 1;

                  // Hit particles
                  for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    setEffects(ef => [...ef, {
                      id: Date.now() + Math.random(),
                      x: enemy.x,
                      y: enemy.y,
                      vx: Math.cos(angle) * 3,
                      vy: Math.sin(angle) * 3,
                      life: 20,
                      color: proj.color,
                      size: 5
                    }]);
                  }

                  if (enemy.health <= 0) {
                    const comboBonus = Math.floor(combo / 5);
                    const points = enemy.points * (1 + comboBonus);
                    setScore(s => s + points);
                    setKills(k => k + 1);
                    setCombo(c => {
                      const newCombo = c + 1;
                      setMaxCombo(max => Math.max(max, newCombo));
                      return newCombo;
                    });

                    // Death explosion
                    for (let i = 0; i < 20; i++) {
                      setEffects(ef => [...ef, {
                        id: Date.now() + Math.random(),
                        x: enemy.x,
                        y: enemy.y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 40,
                        color: enemy.color,
                        size: 8
                      }]);
                    }

                    setEffects(ef => [...ef, {
                      id: Date.now() + Math.random(),
                      x: enemy.x,
                      y: enemy.y,
                      vx: 0,
                      vy: -2,
                      life: 30,
                      color: '#ffd700',
                      size: 1,
                      text: `+${points}`,
                      isText: true
                    }]);

                    return null;
                  }
                }
              }
              return enemy;
            }).filter(e => e !== null);
          });

          if (hit) return null;
          return proj;
        }).filter(p => p !== null);
      });

      // Draw projectiles
      projectiles.forEach(proj => {
        ctx.fillStyle = proj.color;
        ctx.shadowColor = proj.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Trail
        for (let i = 1; i <= 3; i++) {
          ctx.fillStyle = `rgba(255, 215, 0, ${0.5 - i * 0.15})`;
          ctx.beginPath();
          ctx.arc(proj.x, proj.y + i * 10, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Update and draw effects
      setEffects(prev => {
        return prev.map(effect => {
          effect.x += effect.vx;
          effect.y += effect.vy;
          effect.life -= 1;
          effect.size *= 0.97;

          if (effect.life <= 0) return null;
          return effect;
        }).filter(e => e !== null);
      });

      effects.forEach(effect => {
        if (effect.isText) return;
        
        const alpha = effect.life / 30;
        ctx.fillStyle = effect.color.includes('rgb') 
          ? effect.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba')
          : effect.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
        ctx.fill();
      });

      // Combo display
      if (combo > 0) {
        ctx.save();
        ctx.translate(CANVAS_WIDTH / 2, 80);
        
        const scale = 1 + Math.min(combo / 20, 0.5);
        ctx.scale(scale, scale);
        
        ctx.fillStyle = combo >= 20 ? '#ff0000' : combo >= 10 ? '#ff6b00' : '#ffd700';
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fillText(`${combo}x`, 0, 0);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 20px Arial';
        ctx.fillText('COMBO', 0, 25);
        
        ctx.restore();
      }

      animationFrameId = requestAnimationFrame(gameLoop);
    };

    gameLoop();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [gameState, enemies, projectiles, effects, combo, cannons]);

  const handleCannonClick = (e) => {
    if (gameState !== 'playing') return;

    const rect = canvasRef.current.getBoundingClientRect();
    const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
    const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;

    const scaleX = CANVAS_WIDTH / rect.width;
    const scaleY = CANVAS_HEIGHT / rect.height;
    const canvasX = x * scaleX;
    const canvasY = y * scaleY;

    // Check if clicked on cannon area
    if (canvasY > CANVAS_HEIGHT - 100) {
      const lane = Math.floor(canvasX / LANE_WIDTH);
      if (lane >= 0 && lane < NUM_LANES && cannons[lane]?.canFire) {
        fireCannon(lane);
      }
    }
  };

  const fireCannon = (lane) => {
    const x = lane * LANE_WIDTH + LANE_WIDTH / 2;
    const y = CANVAS_HEIGHT - 70;

    // Create projectile
    setProjectiles(prev => [...prev, {
      id: Date.now(),
      lane,
      x,
      y: y - 30,
      speed: 10,
      color: '#ffd700'
    }]);

    // Cannon fire effect
    for (let i = 0; i < 5; i++) {
      setEffects(ef => [...ef, {
        id: Date.now() + Math.random(),
        x,
        y: y - 30,
        vx: (Math.random() - 0.5) * 3,
        vy: -Math.random() * 3,
        life: 15,
        color: '#ff6600',
        size: 6
      }]);
    }

    // Update cannon cooldown
    setCannons(prev => prev.map((cannon, i) => 
      i === lane ? { ...cannon, canFire: false, lastFired: Date.now() } : cannon
    ));

    // Reset cooldown
    setTimeout(() => {
      setCannons(prev => prev.map((cannon, i) => 
        i === lane ? { ...cannon, canFire: true } : cannon
      ));
    }, CANNON_COOLDOWN);
  };

  useEffect(() => {
    if (gameState !== 'playing') return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const drawTextEffects = () => {
      effects.forEach(effect => {
        if (effect.isText) {
          const alpha = effect.life / 30;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = effect.color;
          ctx.font = 'bold 30px Arial';
          ctx.textAlign = 'center';
          ctx.shadowColor = effect.color;
          ctx.shadowBlur = 10;
          ctx.fillText(effect.text, effect.x, effect.y);
          ctx.shadowBlur = 0;
          ctx.restore();
        }
      });
    };

    const interval = setInterval(drawTextEffects, 16);
    return () => clearInterval(interval);
  }, [gameState, effects]);

  const startGame = () => {
    setGameState('playing');
    setScore(0);
    setWave(1);
    setLives(10);
    setEnemies([]);
    setProjectiles([]);
    setEffects([]);
    setCombo(0);
    setMaxCombo(0);
    setKills(0);
    
    // Initialize cannons
    const initialCannons = [];
    for (let i = 0; i < NUM_LANES; i++) {
      initialCannons.push({ lane: i, canFire: true, lastFired: 0 });
    }
    setCannons(initialCannons);
  };

  if (gameState === 'menu') {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900">
        <div className="text-center text-white p-8 bg-black bg-opacity-70 rounded-3xl max-w-2xl mx-4 border-2 border-purple-500">
          <div className="mb-6">
            <div className="text-7xl mb-4">ğŸ¯ğŸ’£</div>
            <h1 className="text-6xl font-bold mb-2 bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400 bg-clip-text text-transparent">
              ëŒ€í¬ ë””íœë”
            </h1>
            <p className="text-gray-300 text-xl">ëŒ€í¬ë¥¼ ë°œì‚¬í•´ì„œ ì ì„ ë§‰ì•„ë¼!</p>
          </div>

          {highScore > 0 && (
            <div className="bg-yellow-900 bg-opacity-50 rounded-2xl p-4 mb-6 border-2 border-yellow-500">
              <div className="flex items-center justify-center gap-2 mb-2">
                <Trophy className="w-6 h-6 text-yellow-400" />
                <span className="text-yellow-300 font-bold">ìµœê³  ê¸°ë¡</span>
              </div>
              <div className="text-4xl font-bold text-yellow-400">{highScore.toLocaleString()}</div>
            </div>
          )}

          <button
            onClick={startGame}
            className="w-full bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-bold py-6 px-8 rounded-2xl text-3xl mb-6 transform hover:scale-105 transition shadow-2xl"
          >
            ğŸ’£ ì „íˆ¬ ì‹œì‘
          </button>

          <div className="text-left bg-gray-900 bg-opacity-80 p-6 rounded-2xl space-y-3 border border-purple-500">
            <h3 className="text-2xl font-bold mb-3 text-purple-400">ğŸ® ê²Œì„ ë°©ë²•</h3>
            <p className="text-gray-300 text-lg">ğŸ’£ í•˜ë‹¨ì˜ ëŒ€í¬ë¥¼ íƒ­í•´ì„œ ë°œì‚¬!</p>
            <p className="text-gray-300 text-lg">â¬‡ï¸ 5ê°œì˜ ë ˆì¸ì—ì„œ ì ë“¤ì´ ë‚™í•˜</p>
            <p className="text-gray-300 text-lg">ğŸ¯ ëŒ€í¬ëŠ” ë ˆì¸ë³„ë¡œ ë°œì‚¬ë©ë‹ˆë‹¤</p>
            <p className="text-yellow-400 text-lg">â±ï¸ ì¿¨ë‹¤ìš´: 0.8ì´ˆ</p>
            <p className="text-green-400 text-lg">ğŸ’š ì´ˆë¡ìƒ‰ = ë°œì‚¬ ê°€ëŠ¥</p>
            <div className="mt-4 space-y-2 bg-purple-900 bg-opacity-50 p-4 rounded-lg">
              <p className="text-cyan-300 font-bold">ğŸ‘¾ ì  íƒ€ì…:</p>
              <p className="text-sm"><span className="text-red-400">â—</span> ì¼ë°˜ (HP 1, +10ì )</p>
              <p className="text-sm"><span className="text-blue-400">â—</span> ë¹ ë¦„ (HP 1, ë¹ ë¥¸ ì†ë„, +20ì )</p>
              <p className="text-sm"><span className="text-purple-400">â—</span> íƒ±í¬ (HP 3, ëŠë¦¼, +30ì )</p>
              <p className="text-sm"><span className="text-yellow-400">â—</span> ë³´ìŠ¤ (HP 5, ë§¤ìš° ëŠë¦¼, +100ì )</p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (gameState === 'gameover') {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-red-900 via-purple-900 to-black">
        <div className="text-center text-white p-8 bg-black bg-opacity-70 rounded-3xl max-w-md mx-4 border-2 border-red-500">
          <div className="mb-6">
            <div className="text-7xl mb-4">ğŸ’¥</div>
            <h1 className="text-5xl font-bold mb-4 text-red-400">ê¸°ì§€ í•¨ë½!</h1>
          </div>

          <div className="bg-blue-900 bg-opacity-50 rounded-2xl p-6 mb-6 border-2 border-blue-500">
            <p className="text-gray-300 mb-2">ìµœì¢… ì ìˆ˜</p>
            <div className="text-6xl font-bold mb-4">{score.toLocaleString()}</div>
            {score === highScore && score > 0 && (
              <div className="bg-yellow-500 text-yellow-900 font-bold py-2 px-4 rounded-full inline-block">
                ğŸ‰ ì‹ ê¸°ë¡!
              </div>
            )}
          </div>

          <div className="grid grid-cols-3 gap-3 mb-6">
            <div className="bg-purple-900 bg-opacity-50 rounded-2xl p-4 border border-purple-500">
              <Target className="w-5 h-5 mx-auto mb-2 text-purple-400" />
              <p className="text-xs text-gray-300">ì²˜ì¹˜</p>
              <p className="text-xl font-bold">{kills}</p>
            </div>
            <div className="bg-orange-900 bg-opacity-50 rounded-2xl p-4 border border-orange-500">
              <Flame className="w-5 h-5 mx-auto mb-2 text-orange-400" />
              <p className="text-xs text-gray-300">ìµœëŒ€ ì½¤ë³´</p>
              <p className="text-xl font-bold">{maxCombo}</p>
            </div>
            <div className="bg-blue-900 bg-opacity-50 rounded-2xl p-4 border border-blue-500">
              <Shield className="w-5 h-5 mx-auto mb-2 text-blue-400" />
              <p className="text-xs text-gray-300">ì›¨ì´ë¸Œ</p>
              <p className="text-xl font-bold">{wave}</p>
            </div>
          </div>

          {highScore > 0 && score !== highScore && (
            <div className="bg-gray-800 bg-opacity-50 rounded-2xl p-4 mb-6 border border-gray-600">
              <p className="text-gray-400 text-sm mb-1">ìµœê³  ê¸°ë¡</p>
              <p className="text-2xl font-bold text-yellow-400">{highScore.toLocaleString()}</p>
            </div>
          )}

          <button
            onClick={startGame}
            className="w-full bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-bold py-5 px-8 rounded-2xl text-2xl transform hover:scale-105 transition shadow-2xl"
          >
            ğŸ”„ ì¬ë„ì „
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-gray-900 via-indigo-900 to-purple-900 p-4">
      {/* Stats */}
      <div className="flex gap-4 mb-4 flex-wrap justify-center">
        <div className="bg-black bg-opacity-70 px-6 py-3 rounded-xl text-white flex items-center gap-2 border-2 border-yellow-500">
          <Trophy className="w-6 h-6 text-yellow-400" />
          <div>
            <div className="text-xs text-gray-400">ì ìˆ˜</div>
            <div className="font-bold text-xl">{score.toLocaleString()}</div>
          </div>
        </div>
        <div className="bg-black bg-opacity-70 px-6 py-3 rounded-xl text-white flex items-center gap-2 border-2 border-purple-500">
          <Shield className="w-6 h-6 text-purple-400" />
          <div>
            <div className="text-xs text-gray-400">ì›¨ì´ë¸Œ</div>
            <div className="font-bold text-xl">{wave}</div>
          </div>
        </div>
        <div className="bg-black bg-opacity-70 px-6 py-3 rounded-xl text-white flex items-center gap-2 border-2 border-red-500">
          <Heart className="w-6 h-6 text-red-400" />
          <div>
            <div className="text-xs text-gray-400">ìƒëª…</div>
            <div className="font-bold text-xl">{lives}</div>
          </div>
        </div>
        {combo > 0 && (
          <div className="bg-gradient-to-r from-yellow-600 to-orange-600 px-6 py-3 rounded-xl text-white flex items-center gap-2 animate-pulse border-2 border-yellow-400">
            <Zap className="w-6 h-6" />
            <div className="font-bold text-xl">{combo}x</div>
          </div>
        )}
      </div>

      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        onClick={handleCannonClick}
        onTouchStart={handleCannonClick}
        className="border-4 border-purple-500 rounded-2xl cursor-pointer shadow-2xl touch-none"
        style={{ maxWidth: '100%', height: 'auto' }}
      />

      <div className="mt-4 text-white text-center bg-black bg-opacity-70 p-4 rounded-2xl max-w-2xl border-2 border-blue-500">
        <p className="text-lg font-bold mb-2 text-cyan-400">
          {enemies.length > 10 ? 'âš ï¸ ëŒ€ê·œëª¨ ê³µê²©!' : 
           enemies.length > 5 ? 'ğŸ¯ ì ì´ ë‹¤ê°€ì˜µë‹ˆë‹¤!' :
           'âœ¨ ë‹¤ìŒ ì›¨ì´ë¸Œ ì¤€ë¹„...'}
        </p>
        <p className="text-sm text-gray-400">
          í•˜ë‹¨ì˜ ëŒ€í¬ë¥¼ íƒ­í•´ì„œ ë°œì‚¬í•˜ì„¸ìš”! â€¢ ì êµ°: {enemies.length} â€¢ ì²˜ì¹˜: {kills}
        </p>
        <p className="text-xs text-green-400 mt-2">
          ğŸ’¡ ì´ˆë¡ìƒ‰ ëŒ€í¬ = ë°œì‚¬ ê°€ëŠ¥ â€¢ íšŒìƒ‰ = ì¬ì¥ì „ ì¤‘
        </p>
      </div>
    </div>
  );
};

export default MultiLaneTapDefense;